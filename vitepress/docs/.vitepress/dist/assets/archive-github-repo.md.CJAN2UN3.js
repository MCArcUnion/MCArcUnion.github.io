import{_ as t,c as e,o as a,a4 as d}from"./chunks/framework.4aTu-Nia.js";const m=JSON.parse('{"title":"存档 GitHub 仓库","description":"","frontmatter":{},"headers":[],"relativePath":"archive-github-repo.md","filePath":"archive-github-repo.md","lastUpdated":null}'),i={name:"archive-github-repo.md"},s=d(`<h1 id="存档-github-仓库" tabindex="-1">存档 GitHub 仓库 <a class="header-anchor" href="#存档-github-仓库" aria-label="Permalink to &quot;存档 GitHub 仓库&quot;">​</a></h1><p>许多第三方软件与应用程序（照着 bedev 写的。二者有什么区别吗？问咩咩）都会选择开放源代码，并使用 Git 进行多人协作与版本控制，而最常用的源代码托管平台非 GitHub 莫属。此时，使用合适的方法备份这些资源就显得十分重要。本页面记录了如何备份 GitHub 仓库。</p><p>顺带一提，本文的作者在某一天意外地发现服务端开发者 Sysca11 注销（歧义？）了账号，导致 BedrockX 等已停更服务端的主仓库被删除。因此他决定抓紧时间备份已停更软件与应用程序的 Git 仓库，并写下了这篇教程。</p><h2 id="存档-git-仓库" tabindex="-1">存档 Git 仓库 <a class="header-anchor" href="#存档-git-仓库" aria-label="Permalink to &quot;存档 Git 仓库&quot;">​</a></h2><p>每个 GitHub 仓库的主体都是一个 Git 仓库，它是树状结构，忠诚地记录了源代码的所有版本。（我没有系统学过Git，部分名词可能不专业，请高人指正）</p><p>通常情况下，我们从 GitHub 拉取 Git 仓库到本地时，会使用如下命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>git clone https://github.com/username/reponame.git</span></span></code></pre></div><p>代码块里不能用斜体！！气死我了不管了（细想也有道理，代码应该是纯文本）</p><p><s><pre><code>git clone <a href="https://github.com/" target="_blank" rel="noreferrer">https://github.com/</a><em>username</em>/<em>reponame</em>.git</code></pre></s></p><p>其中 <code>username</code> 是用户名，<code>reponame</code> 是仓库名。这样可以克隆绝大部分东西，比如所有的提交（commit），但是，现实远比这复杂。</p><p>为了确保我们可以克隆到尽可能多的东西，我们必须花费一些心思了：</p><h3 id="寻找原始的仓库" tabindex="-1">寻找原始的仓库 <a class="header-anchor" href="#寻找原始的仓库" aria-label="Permalink to &quot;寻找原始的仓库&quot;">​</a></h3><p>首先，我们需要找到尽可能原始的仓库：</p><ol><li><p>直接克隆 GitHub 上的主仓库（？）。</p><p>主仓库包含最全面的信息。</p><p>使用 <code>--mirror</code> 参数可以额外克隆remote branches和other refs，它们可能有用处但用处不大，所以即使没能使用 <code>--mirror</code> 参数克隆到主仓库也不必懊恼。</p></li><li><p>克隆 GitHub 上对主仓库的复刻（fork）。</p><p>如果主仓库已经被删除，那么你可以找找看有没有留存下来的复刻。</p><p>但是，不是所有的复刻都与主仓库相同。有些复刻的创建者可能在复刻后忘了及时更新（在以前这比较麻烦，但现在只需点击“Sync fork”即可），导致复刻落后于主仓库；有些复刻的创建者可能会向复刻中加入自己的提交（比如，使用Pull Request来更新复刻，或者添加一些小功能），但大多数添加都不是很重要。</p><p>下表中使用“落后”、“超前”和“等价”来表示各个复刻与主仓库之间的关系。其中“落后”指该复刻缺少主仓库的部分提交；“超前”指该复刻加入了主仓库所没有的提交；“等价”指该复刻的提交与主仓库的提交完全相同。判断复刻是否等价的方法非常简单：只需看该复刻的最后一次提交与主仓库的（<code>11b79db</code>）是否相同。</p><details><summary>BedrockX及其现存复刻（fork）列表</summary><p>（主仓库以提交 <code>11b79dbede565a0e58c82a3e5011dc5bf67ceb37</code> 为准）（落后与超前有争议）</p><table><thead><tr><th>仓库</th><th>提交（commit）数量</th><th>与主仓库的关系</th></tr></thead><tbody><tr><td>Sysca11（原主仓库）</td><td>57</td><td>—</td></tr><tr><td>3JoB</td><td>58</td><td>超前</td></tr><tr><td>allankevinrichie</td><td>59</td><td>落后且超前</td></tr><tr><td>CivicXFB</td><td>57</td><td>等价</td></tr><tr><td>Extollite（现主仓库）</td><td>31</td><td>落后</td></tr><tr><td>hapi888</td><td>57</td><td>等价</td></tr><tr><td>jfishing</td><td>57</td><td>等价</td></tr><tr><td>mclk623</td><td>57</td><td>等价</td></tr><tr><td>moxisuki</td><td>57</td><td>等价</td></tr><tr><td>oldsheep0205</td><td>43</td><td>落后</td></tr><tr><td>Rhycraft</td><td>33</td><td>落后</td></tr><tr><td>SakuranaRanbom</td><td>57</td><td>等价</td></tr><tr><td>saranfeishuang</td><td>46</td><td>落后</td></tr><tr><td>ShrBox</td><td>57</td><td>等价</td></tr><tr><td>SkipM4</td><td>57</td><td>等价</td></tr><tr><td>untitledunrevised</td><td>31</td><td>落后</td></tr><tr><td>whoismek</td><td>57</td><td>等价</td></tr><tr><td>WillowSauceR</td><td>58</td><td>超前</td></tr><tr><td>yzu999</td><td>57</td><td>等价</td></tr></tbody></table></details></li><li><p>从自己或他人的存储中取得。</p><p>如果主仓库已经被删除，而且所有的复刻都被删除或者不完整（判断复刻是否完整的方法见上），那么你只能试着从自己的私人存储中寻找仓库，或者询问其他相关的人（比如开发者），看看他们有没有留存备份。</p></li></ol><p>如果以上的方法都没有奏效，那么很不幸，你只能选择一份尽可能原始的仓库进行存档了。</p><h3 id="克隆仓库" tabindex="-1">克隆仓库 <a class="header-anchor" href="#克隆仓库" aria-label="Permalink to &quot;克隆仓库&quot;">​</a></h3><p><em>如果你通过方法 3 找到了仓库，请把它复制到你的工作目录下，然后跳过这一（段落or章节？）。</em></p><p>克隆仓库，并下载所有LFS文件：<sup><a href="#注释">[注 1]</a></sup></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>git clone --mirror https://github.com/username/reponame.git</span></span>
<span class="line"><span>cd reponame.git</span></span>
<span class="line"><span>git lfs fetch --all</span></span></code></pre></div><h3 id="bundle-仓库" tabindex="-1">bundle 仓库 <a class="header-anchor" href="#bundle-仓库" aria-label="Permalink to &quot;bundle 仓库&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>git bundle create &quot;../GitHub username reponame.bundle&quot; --all</span></span></code></pre></div><h2 id="存档-releases" tabindex="-1">存档 Releases <a class="header-anchor" href="#存档-releases" aria-label="Permalink to &quot;存档 Releases&quot;">​</a></h2><h2 id="存档-issues-与-pull-requests" tabindex="-1">存档 Issues 与 Pull Requests <a class="header-anchor" href="#存档-issues-与-pull-requests" aria-label="Permalink to &quot;存档 Issues 与 Pull Requests&quot;">​</a></h2><h2 id="存档-wiki" tabindex="-1">存档 Wiki <a class="header-anchor" href="#存档-wiki" aria-label="Permalink to &quot;存档 Wiki&quot;">​</a></h2><p>GitHub 仓库中的 Wiki 本质上就是一个 Git 仓库，你可以使用上面的方法克隆并 bundle 它。</p><h2 id="注释" tabindex="-1">注释 <a class="header-anchor" href="#注释" aria-label="Permalink to &quot;注释&quot;">​</a></h2><ol><li>有时，执行 <code>git lfs fetch --all</code> 会输出类似信息：<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>fetch: 1 object found, done.</span></span></code></pre></div>但是并不会下载任何东西。这是因为 Git LFS 把空文件当作了 LFS 指针。详见 <a href="https://github.com/git-lfs/git-lfs/discussions/5123" target="_blank" rel="noreferrer">https://github.com/git-lfs/git-lfs/discussions/5123</a>。</li></ol><p>（脚注暂未写入gfm，故暂不使用）</p><p>Here is a simple footnote[^1].</p><p>A footnote can also have multiple lines[^2].</p><p>You can also use words, to fit your writing style more closely[^note].</p><p>[^1]: My reference. [^2]: Every new line should be prefixed with 2 spaces.<br> This allows you to have a footnote with multiple lines. [^note]: Named footnotes will still render with numbers instead of the text but allow easier identification and linking.<br> This footnote also has been made with a different syntax using 4 spaces for new lines.</p>`,32),r=[s];function o(l,n,p,h,c,u){return a(),e("div",null,r)}const g=t(i,[["render",o]]);export{m as __pageData,g as default};
